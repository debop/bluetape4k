package io.bluetape4k.workshop.redis.examples.stream.reactive

import io.bluetape4k.junit5.coroutines.runSuspendWithIO
import io.bluetape4k.logging.KLogging
import io.bluetape4k.logging.debug
import io.bluetape4k.workshop.redis.examples.stream.RedisStreamConfiguration
import io.bluetape4k.workshop.redis.examples.stream.SensorData
import kotlinx.coroutines.delay
import kotlinx.coroutines.flow.toList
import kotlinx.coroutines.reactive.asFlow
import kotlinx.coroutines.reactive.awaitFirstOrNull
import kotlinx.coroutines.reactor.awaitSingle
import kotlinx.coroutines.runBlocking
import org.amshove.kluent.internal.assertFailsWith
import org.amshove.kluent.shouldBeEqualTo
import org.amshove.kluent.shouldBeTrue
import org.awaitility.kotlin.atMost
import org.awaitility.kotlin.await
import org.awaitility.kotlin.until
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.Test
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.boot.test.context.SpringBootTest
import org.springframework.data.redis.RedisSystemException
import org.springframework.data.redis.connection.stream.MapRecord
import org.springframework.data.redis.connection.stream.ReadOffset
import org.springframework.data.redis.connection.stream.RecordId
import org.springframework.data.redis.connection.stream.StreamOffset
import org.springframework.data.redis.core.ReactiveStreamOperations
import org.springframework.data.redis.core.ReactiveStringRedisTemplate
import org.springframework.data.redis.stream.StreamReceiver
import java.time.Duration
import java.util.concurrent.LinkedBlockingDeque

@SpringBootTest(classes = [RedisStreamConfiguration::class])
class ReactiveStreamApiTest(
    @Autowired private val template: ReactiveStringRedisTemplate,
    @Autowired private val streamReceiver: StreamReceiver<String, MapRecord<String, String, String>>,
) {

    companion object: KLogging()

    private val streamOps: ReactiveStreamOperations<String, String, String> = template.opsForStream()

    @BeforeEach
    fun beforeEach() {
        runBlocking {
            template.connectionFactory.reactiveConnection.serverCommands().flushAll().awaitSingle()
        }
    }

    @Test
    fun `send to stream by XADD, and read record by XREAD`() = runSuspendWithIO {

        // Send to stream by XADD
        //
        val fixedId1 = streamOps.add(SensorData.RECORD_1234_0).awaitSingle()
        log.debug { "fixedId1=$fixedId1" }
        fixedId1 shouldBeEqualTo SensorData.RECORD_1234_0.id

        val fixedId2 = streamOps.add(SensorData.RECORD_1234_1).awaitSingle()
        log.debug { "fixedId2=$fixedId2" }
        fixedId2 shouldBeEqualTo SensorData.RECORD_1234_1.id

        // XLEN
        //
        streamOps.size(SensorData.KEY).awaitSingle() shouldBeEqualTo 2L

        // 마지막 XADD 이후에 id 에 Timestamp 가 더 작은 값을 추가하려고 하면 예외가 발생한다.
        // 참고: RecordId 는 `epoch milliseconds-sequence id` 형식으로 구성됩니다.
        assertFailsWith<RedisSystemException> {
            val record = SensorData.create("1234", "19.8", "invalid")
                .withId(RecordId.of("0-0"))  // timestamp 값이 0 이므로 예외가 발생한다.

            streamOps.add(record).awaitSingle()
        }

        // XADD with auto generated id
        val autoGeneratedId = streamOps.add(SensorData.create("1234", "19.8", "")).awaitSingle()
        // 참고: RecordId 는 `epoch milliseconds-sequence id` 형식으로 구성됩니다. 해당 timestamp 에 첫번째 sequence 이므로
        autoGeneratedId.value.endsWith("-0").shouldBeTrue()
        streamOps.size(SensorData.KEY).awaitSingle() shouldBeEqualTo 3L

        // XREAD from start of stream (Kafka의 earliest 전략과 같다)
        val fromStart = streamOps.read(StreamOffset.fromStart(SensorData.KEY)).asFlow().toList()
        fromStart.size shouldBeEqualTo 3
        fromStart.map { it.id } shouldBeEqualTo listOf(fixedId1, fixedId2, autoGeneratedId)

        // XREAD resume after fiexedId2 (Kafka의 latest 전략과 같다)
        val fromOffset =
            streamOps.read(StreamOffset.create(SensorData.KEY, ReadOffset.from(fixedId2))).asFlow().toList()
        fromOffset.size shouldBeEqualTo 1
        fromOffset.map { it.id } shouldBeEqualTo listOf(autoGeneratedId)
    }

    @Test
    fun `stream listener 를 통한 연속적 읽기`() = runSuspendWithIO {
        val received = LinkedBlockingDeque<MapRecord<String, String, String>>()

        streamReceiver
            .receive(StreamOffset.fromStart(SensorData.KEY))
            .doOnNext {
                println("received and emit: $it")
                received.add(it)
            }
            .doOnComplete { println("Complete") }
            .subscribe()

        streamOps.add(SensorData.RECORD_1234_0).awaitSingle()
        streamOps.add(SensorData.RECORD_1234_1).awaitSingle()
        delay(30)
        await atMost Duration.ofMillis(300) until { received.size == 2 }

        streamOps.add(SensorData.RECORD_1235_0).awaitFirstOrNull()
        delay(30)
        await atMost Duration.ofMillis(300) until { received.size == 3 }
    }
}
