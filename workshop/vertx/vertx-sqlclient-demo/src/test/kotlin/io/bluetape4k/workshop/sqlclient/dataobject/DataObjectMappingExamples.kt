package io.bluetape4k.workshop.sqlclient.dataobject

import io.bluetape4k.junit5.coroutines.runSuspendWithIO
import io.bluetape4k.logging.KLogging
import io.bluetape4k.logging.debug
import io.bluetape4k.vertx.sqlclient.tests.testWithTransactionSuspending
import io.bluetape4k.workshop.sqlclient.AbstractSqlClientTest
import io.vertx.core.Vertx
import io.vertx.junit5.VertxTestContext
import io.vertx.kotlin.coroutines.await
import io.vertx.kotlin.coroutines.dispatcher
import io.vertx.sqlclient.RowSet
import io.vertx.sqlclient.SqlConnection
import io.vertx.sqlclient.templates.SqlTemplate
import kotlinx.coroutines.runBlocking
import org.amshove.kluent.shouldBeEqualTo
import org.junit.jupiter.api.BeforeAll
import org.junit.jupiter.api.Disabled
import org.junit.jupiter.api.Test

/**
 * Data object mapping example
 *
 * 참고: [Mapping with Vert.x data objects](https://vertx.io/docs/vertx-sql-client-templates/java/#_mapping_with_vert_x_data_objects)
 */
// @Disabled("Kotlin 은 제대로 지원하지 않는다")
class DataObjectMappingExamples: AbstractSqlClientTest() {

    companion object: KLogging()

    @BeforeAll
    fun setup(vertx: Vertx) {
        // setup 에서는 testContext 가 불필요합니다. 만약 injection을 받으면 꼭 completeNow() 를 호출해야 합니다.
        runBlocking(vertx.dispatcher()) {
            val pool = vertx.getH2Pool()
            pool.withTransaction { conn: SqlConnection ->
                conn
                    .query(
                        """
                        DROP TABLE users IF EXISTS;
                        CREATE TABLE IF NOT EXISTS users(
                             id LONG PRIMARY KEY,
                             first_name VARCHAR(255),
                             last_name VARCHAR(255)
                        )
                        """.trimMargin()
                    )
                    .execute()
                    .compose {
                        conn.query("INSERT INTO users VALUES (1, 'John', 'Doe'), (2, 'Jane', 'Doe')").execute()
                    }
            }.await()
            pool.close().await()
        }
    }

    @Test
    fun `binding row with row mapper which generated by @RowMapper`(
        vertx: Vertx,
        testContext: VertxTestContext,
    ) = runSuspendWithIO {
        val pool = vertx.getH2Pool()
        vertx.testWithTransactionSuspending(testContext, pool) {

            val users: RowSet<UserDataObject> = SqlTemplate
                .forQuery(pool, "SELECT * FROM users WHERE id=#{id}")
                .mapTo(UserDataObjectRowMapper.INSTANCE)
                .execute(mapOf("id" to 1L))
                .await()

            users.size() shouldBeEqualTo 1
            val user = users.first()
            log.debug { "User id=${user.id}, firstName=${user.firstName}, lastName=${user.lastName}" }
        }
        pool.close().await()
    }

    @Disabled("Kotlin 에서 @ParametersMapped 를 이용한 Parrameter Mapping 코드 생성에 문제가 있다.")
    // 어쩔 수 없이 USER_TUPLE_MAPPER 를 사용해야 한다 
    @Test
    fun `binding parameter with parameters mapper with generated by @ParametersMapped`(
        vertx: Vertx,
        testContext: VertxTestContext,
    ) = runSuspendWithIO {
        val pool = vertx.getH2Pool()
        vertx.testWithTransactionSuspending(testContext, pool) {

            val user = UserDataObject().apply {
                id = 42
                firstName = "Alien"
                lastName = "Lukas"
            }

            // FIXME: Kotlin 에서 @ParametersMapped 를 이용한 Parrameter Mapping 코드 생성에 문제가 있다.
//            val result = SqlTemplate
//                .forUpdate(pool, "INSERT INTO users VALUES (#{id}, #{firstName}, #{lastName})")
//                .mapFrom(UserDataObjectParametersMapper.INSTANCE)
//                .execute(user)
//                .await()

        }
        pool.close().await()
    }
}
