package io.bluetape4k.data.jdbc.sql

import io.bluetape4k.core.assertNotBlank
import java.sql.Connection
import java.sql.ResultSet
import java.sql.Statement
import javax.sql.DataSource

/**
 * 새로운 Connection을 만들어서, 작업을 수행합니다.
 *
 * @param T 결과 수형
 * @param block 새로 연결한 [Connection]을 이용한 작업 코드 블럭
 * @return 작업 결과
 */
inline fun <T> DataSource.withConnect(crossinline block: (Connection) -> T): T {
    return connection?.use { conn ->
        block(conn)
    } ?: error("No connection returns from DataSource[$this]")
}

/**
 * 지정한 Statement 작업을 수행합니다.
 *
 * @param T      결과 수형
 * @param block [Statement]를 수행하는 코드 블럭
 * @return 작업 결과
 */
inline fun <T> DataSource.withStatement(crossinline block: (Statement) -> T): T {
    return withConnect { conn ->
        conn.withStatement(block)
    }
}

inline fun <T> DataSource.runQuery(sql: String, crossinline mapper: (ResultSet) -> T): T {
    sql.assertNotBlank("sql")
    return withConnect { conn ->
        conn.runQuery(sql, mapper)
    }
}

fun DataSource.executeUpdate(sql: String): Int {
    sql.assertNotBlank("sql")
    return withConnect { conn ->
        conn.executeUpdate(sql)
    }
}

fun DataSource.executeUpdate(sql: String, autoGeneratedKeys: Int): Int {
    sql.assertNotBlank("sql")
    return withConnect { conn ->
        conn.executeUpdate(sql, autoGeneratedKeys)
    }
}

fun DataSource.executeUpdate(sql: String, vararg columnIndexes: Int): Int {
    sql.assertNotBlank("sql")
    return withConnect { conn ->
        conn.executeUpdate(sql, *columnIndexes)
    }
}

fun DataSource.executeUpdate(sql: String, vararg columnLabels: String): Int {
    sql.assertNotBlank("sql")
    return withConnect { conn ->
        conn.executeUpdate(sql, *columnLabels)
    }
}
