package io.bluetape4k.data.jdbc.sql

import io.bluetape4k.core.assertNotBlank
import java.sql.Connection
import java.sql.ResultSet
import java.sql.Statement


/**
 * 새로운 [Statement]를 생성하고, 그 것을 이용하여 데이터를 조회합니다.
 *
 * @param T 결과 수형
 * @param block [Statement]를 사용하여 결과를 가져오는 코드 블럭
 * @return 조회한 결과
 */
inline fun <T> Connection.withStatement(block: (Statement) -> T): T =
    this.createStatement().use {
        block(it)
    }

/**
 * [sql]을 수행하고, 결과를 [mapper]를 통해 변환한 값을 반환합니다.
 *
 * @param T    결과 수형
 * @param sql  실행할 sql 구문
 * @param mapper ResultSet을 결과 수형으로 변환하는 mapper
 * @return 변환된 결과
 */
inline fun <T> Connection.runQuery(sql: String, crossinline mapper: (ResultSet) -> T): T {
    sql.assertNotBlank("sql")
    return withStatement { stmt ->
        stmt.executeQuery(sql).use(mapper)
    }
}

fun Connection.executeUpdate(sql: String): Int {
    sql.assertNotBlank("sql")
    return withStatement { stmt ->
        stmt.executeUpdate(sql)
    }
}

fun Connection.executeUpdate(sql: String, autoGeneratedKeys: Int): Int {
    sql.assertNotBlank("sql")
    return withStatement { stmt ->
        stmt.executeUpdate(sql, autoGeneratedKeys)
    }
}

fun Connection.executeUpdate(sql: String, vararg columnIndexes: Int): Int {
    sql.assertNotBlank("sql")
    return withStatement { stmt ->
        stmt.executeUpdate(sql, columnIndexes)
    }
}

fun Connection.executeUpdate(sql: String, vararg columnLabels: String): Int {
    sql.assertNotBlank("sql")
    return withStatement { stmt ->
        stmt.executeUpdate(sql, columnLabels)
    }
}
